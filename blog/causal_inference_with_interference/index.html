<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-12-01">

<title>Causal Inference With Interference – Mavi, PhD</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-0b37c64f34216b628666a8dac638b53b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<meta name="backup-site" content="https://rajindermavi.github.io">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Mavi, PhD</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../portfolio.html"> 
<span class="menu-text">Portfolio</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/rajinder-mavi/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/rajindermavi"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Causal Inference With Interference</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">AB Testing</div>
                <div class="quarto-category">Data Science</div>
                <div class="quarto-category">Statistics</div>
                <div class="quarto-category">Academic</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">December 1, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>Lately I’ve been exploring research in causal inference. The last 15 years have been a remarkable journey in the topic of causal inference with interference. With the advent of large scale social media platforms there has been enormous interest in understanding causal inference in an environment that permits interactions spanning the entire population under consideration.</p>
<p>The goal of causal inference is to understand the causal relationship between an independent and dependent variable. Fundamentally, we would like to understand the impact on the dependent variable <span class="math inline">\(Y_i\)</span> for each individual with a change in the independent variable <span class="math inline">\(z = 0,1\)</span>. Mathematically, this is quantified by the Average Treatment Effect <span id="eq-ate-sutva"><span class="math display">\[
\tau(1,0) = \frac1N\sum_{i=1}^N \left(Y_i(1) - Y_i(0) \right)
\tag{1}\]</span></span> where the difference <span class="math inline">\(Y_i(1) - Y_i(0)\)</span> represents the change in the dependent variable due to the indepedent variable for the <span class="math inline">\(i^{th}\)</span> unit. The fundamental problem of causal inference is that one can only observe a unit’s response under a single treatment. That is, we can measure <span class="math inline">\(Y_i(1)\)</span> or <span class="math inline">\(Y_i(0)\)</span>, but not both. This issue is mitigated in experiments with random assignments of individuals to the control or treatment group. The framework of Stable Unit Treatment Value Assumption (SUTVA) requires no cross dependence across unit treatments and is the primary historical method for estimation of a single, consistent treatment effect on the dependent variable.</p>
<p>The problem of interference within and accross assigment groups of course must immediately be considered unless individuals are completely isolated from one another. Classical approaches to control the interference typically rely on asserting groups of interacting individuals, but no interference between groups. In that case the assignment consideration is taken at a group level <span class="citation" data-cites="Hudgens2008Causal">(<a href="#ref-Hudgens2008Causal" role="doc-biblioref">Hudgens and Halloran 2008</a>)</span>.</p>
<p>In a massively connected component of individuals, there is no hope of assignments of noninteracting groups. Thus interference within the group itself must be controlled. There is an exiting story of the formulation of cluster methods to recover results on treatment effect, that is, the existence of estimators of (<a href="#eq-ate-sutva" class="quarto-xref">Equation&nbsp;1</a>), and controlling their bias and variance.</p>
<p>Background for this note includes the following …</p>
<div class="callout callout-style-default callout-note callout-titled" title="Estimator">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="true" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Estimator
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse show">
<div class="callout-body-container callout-body">
<p>In the language of statistics, an esimator is a formula or rule employed to estimate a quantity of interest based on observed data. An estimator is said to be unbiased if it’s expectation is equal to the quantity of interest.</p>
<p>Familiar examples include the Expectation and Variance estimators for a set of observations <span class="math inline">\((X_1,..,X_n)\)</span> of a random variable <span class="math inline">\(X\)</span> with mean <span class="math inline">\(\mu\)</span> and variance <span class="math inline">\(\sigma^2\)</span>.</p>
<p><strong>Expectation Estimator</strong></p>
<p><span class="math display">\[
\bar X_n = \frac{1}{n} \sum_{i=1}^n X_i
\]</span> The estimator is unbiased since <span class="math display">\[
\mathbb{E} [\bar X_n] = \mu
\]</span></p>
<p>It is useful to find (or at least bound above) the variance of the estimator, since that guarantees a good estimate if it can be shown to be small. The variance is <span class="math display">\[
Var(\bar X_n)  = \mathbb{E}[(\bar X_n - \mathbb{E}[\bar X_n])^2] = \frac{1}{n}\sigma^2
\]</span> so the variance tends to zero with a large sample, assuring a quality estimator that is unbiased and converges to the quantity of interest.</p>
<p><strong>Variance Estimator</strong></p>
<p><span class="math display">\[
S_n^2 = \frac{1}{n-1}\sum_{i=1}^n (X_i - \bar X_n)^2
\]</span> <span class="math display">\[
\mathbb{E} [S_n^2] = \sigma^2
\]</span></p>
<p>The variance is somewhat more complicated, <span class="math display">\[
Var(S^2_n) = \frac1n \left( \mathbb{E}[(X - \mu)^4] -\frac{n-3}{n-1}\sigma^4 \right)
\]</span> nevertheless still tends to zero with a large sample.</p>
<p>Note we did not use the estimator <span class="math display">\[
\tilde S_n^2 = \frac{1}{n}\sum_{i=1}^n (X_i - \bar X_n)^2
\]</span> as this woule have expectation <span class="math display">\[
\mathbb{E} [\tilde S_n^2] = \frac{n-1}{n}\sigma^2
\]</span> and would be a biased estimator.</p>
</div>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled" title="Horvitz Thompson Estimator">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="true" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Horvitz Thompson Estimator
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse show">
<div class="callout-body-container callout-body">
<p>Let $ = {1,2,…,N} $ be a finite population. For each <span class="math inline">\(i\in\mathcal{K}\)</span>, let <span class="math inline">\(Y_i\)</span> be an observable of unit <span class="math inline">\(i\)</span>. Our goal is to estimate <span class="math display">\[
Y = \sum_{i=1}^N Y_i
\]</span> the total of interest. And <span class="math display">\[
\tau = \frac{1}{N}  \sum_{i=1}^N Y_i
\]</span> the average of the population.</p>
<p>To construct the estimator we take a random sample of <span class="math inline">\(n&lt; N\)</span> units from <span class="math inline">\(\mathcal{K}\)</span>. Any sampling method is allowed, but the obtained sample must have distinct units. Let <span class="math inline">\(\pi_i\)</span> be the probability the <span class="math inline">\(i^{th}\)</span> unit is included in the sample (assume <span class="math inline">\(\pi_i &gt; 0\)</span>). Denote the random sample by <span class="math inline">\(\bf{S} = \{i_1,...,i_n\} \subset \mathcal{S}\)</span>. The Horvitz Thompson esimator is <span class="math display">\[
\hat Y_{HT} = \sum_{i\in \bf{S}} \frac{Y_i}{\pi_i} = \sum_{i=1}^N \frac{Y_i 1_{\{i\in \bf S\}}}{\pi_i}
\]</span> and <span class="math display">\[
\hat \tau_{HT} = \frac{1}{N} \hat Y_{HT}
\]</span></p>
<p>The estimator is unbiased <span class="math display">\[
    \mathbb{E}[\hat Y_{HT}] = Y.
\]</span> <span class="math display">\[
    \mathbb{E}[\hat \tau_{HT}] = \tau.
\]</span></p>
<p>To state the variance of <span class="math inline">\(\hat Y_{HT}\)</span>, define <span class="math inline">\(\pi_{ij}\)</span> as the probability that both <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> belong to <span class="math inline">\(\bf{S}\)</span>. The variance of Horvitz Thompson is then <span class="math display">\[
Var(\hat Y_{HT})
    =
        \sum_{i=1}^N \sum_{j=1}^{N} \frac{\pi_{ij} - \pi_i\pi_j}{\pi_i\pi_j} Y_i Y_j
\]</span> it follows from the definition that <span class="math inline">\(\pi_{ii}\)</span> = <span class="math inline">\(\pi_i\)</span>. The variance of tha average estimator is <span class="math display">\[
Var(\hat \tau_{HT})
    =
        \frac{1}{N^2}\sum_{i=1}^N \sum_{j=1}^{N} \frac{\pi_{ij} - \pi_i\pi_j}{\pi_i\pi_j} Y_i Y_j
\]</span></p>
<p>As we want to assure that the Horwitz Thompson estimator converges well to the quantity of interest, controlling the variance is key. It is not hard to see the variance has an upper bound, <span class="math display">\[
Var(\hat Y_{HT}) \leq \sum_{i,j=1}^N \left(\frac{1}{\pi_i^{1/2}\pi_j^{1/2}} - 1\right) Y_i Y_j
\]</span> but if some of the <span class="math inline">\(\pi_i\)</span> are small this raises the small denominator problem. So care would have to be taken in this case. This danger can be mollified through a modification of the HTE, the Hajek estimator. (Also note that as the sample becomes larger, the <span class="math inline">\(\pi_i\)</span> become larger, better controlling the variance.)</p>
<p><strong>Example</strong></p>
<p>Consider a collection of cities with populations greater than some lower bound <span class="math inline">\(b\)</span> in some state. Let the cities be enumerated by <span class="math inline">\(\mathcal{K} =  \{1,2,..,N\}\)</span>. Let <span class="math inline">\(Y_i\)</span> be the total number of hotels in the ith city.</p>
<p>Sample <span class="math inline">\(n\)</span> units from <span class="math inline">\(\mathcal{K}\)</span> by Simple Random Sampling Without Replacement. The inclusion probabilities are <span class="math display">\[
\pi_i = n/N
\]</span> <span class="math display">\[
\pi_{ij} = \frac{n(n-1)}{N(N-1)}
\]</span></p>
<p>The estimate of the average number of hotels in large cities would be given by <span class="math inline">\(\hat Y_{HT}\)</span> after sampling <span class="math display">\[
\hat Y_{HT} = \sum_{i\in \bf{S}} \frac{Y_i}{\pi_i}
= \frac{N}{n}\sum_{i\in \bf{S}} Y_i
\]</span> with variance <span class="math display">\[
Var(\hat Y_{HT}) = N^2 \frac{1 - n/N}{n} S^2
\]</span> where <span class="math inline">\(S^2\)</span> is the population variance. The variance does not tend to zero even as m tends to infinity. But, for the Horwitz Thompson average, <span class="math display">\[
Var(\hat \tau_{HT}) = \frac{1 - n/N}{n} S^2
\]</span> Making a simple assumption <span class="math inline">\(n \propto N^\alpha\)</span> for <span class="math inline">\(0 &lt; \alpha &lt; 1\)</span> or <span class="math inline">\(n = \beta N\)</span> for <span class="math inline">\(0 &lt; \beta &lt; 1\)</span>, the variance of the estimator of the average tends to zero.</p>
</div>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled" title="Basic Graph theory">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-3-contents" aria-controls="callout-3" aria-expanded="true" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Basic Graph theory
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-3" class="callout-3-contents callout-collapse collapse show">
<section id="graph-theory-basics" class="level2 callout-body-container callout-body">
<h2 class="anchored" data-anchor-id="graph-theory-basics">Graph Theory Basics</h2>
<p>A graph is defined as a pair <span class="math inline">\(G = (V, E)\)</span> where <span class="math inline">\(V\)</span> is a finite set of vertices and <span class="math inline">\(E \subseteq \{\{u,v\} : u, v \in V, u \neq v\}\)</span> is a set of unordered edges.</p>
<ul>
<li><strong>Vertices and edges:</strong> Each element <span class="math inline">\(v \in V\)</span> is a vertex. An edge <span class="math inline">\(\{u,v\} \in E\)</span> connects two distinct vertices <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span>.</li>
<li><strong>Adjacency:</strong> Two vertices <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span> are adjacent if <span class="math inline">\(\{u,v\} \in E\)</span>.</li>
<li><strong>Degree:</strong> The degree of a vertex <span class="math inline">\(v\)</span> is <span class="math inline">\(\deg(v) = |\{u \in V : \{u,v\} \in E\}|\)</span>.</li>
</ul>
<section id="neighborhoods" class="level3">
<h3 class="anchored" data-anchor-id="neighborhoods">Neighborhoods</h3>
<p>The (open) neighborhood of a vertex <span class="math inline">\(v\)</span> is <span class="math display">\[
N(v) = \{u \in V : \{u,v\} \in E\}.
\]</span> Including the vertex itself yields the closed neighborhood <span class="math inline">\(N[v] = N(v) \cup \{v\}\)</span>.</p>
</section>
<section id="balls-in-a-graph" class="level3">
<h3 class="anchored" data-anchor-id="balls-in-a-graph">Balls in a Graph</h3>
<p>Using graph distance <span class="math inline">\(d_G(u,v)\)</span> (the length of a shortest path between <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span>), the ball of radius <span class="math inline">\(r \ge 0\)</span> around <span class="math inline">\(v\)</span> is <span class="math display">\[
B_r(v) = \{u \in V : d_G(u,v) \le r\}.
\]</span> When <span class="math inline">\(r = 1\)</span>, <span class="math inline">\(B_1(v) = N[v]\)</span>.</p>
</section>
<section id="annular-regions" class="level3">
<h3 class="anchored" data-anchor-id="annular-regions">Annular Regions</h3>
<p>An annulus (discrete ring) around <span class="math inline">\(v\)</span> between radii <span class="math inline">\(r_1\)</span> and <span class="math inline">\(r_2\)</span> with <span class="math inline">\(0 \le r_1 &lt; r_2\)</span> is <span class="math display">\[
A_{r_1,r_2}(v) = \{u \in V : r_1 &lt; d_G(u,v) \le r_2\}.
\]</span> These layers let us analyze how structure or influence spreads outward from a vertex.</p>
</section>
</section>
</div>
</div>
<p>Enumerate the users <span class="math inline">\(\mathcal{V} = \{v_1,v_2,...,v_N\}\)</span>. Typically, the network is modeled as a graph <span class="math inline">\(\mathcal{G} = (\mathcal{V},\mathcal{E})\)</span>. In our example two units may be connected by an edge if they are freinds. For the sake of the experiment, each user is assigned to one of two groups <span class="math inline">\(z_i = 0,1\)</span>, with <span class="math inline">\(0\)</span> being the control and <span class="math inline">\(1\)</span> being the treatment.</p>
<p>With an assignment of <span class="math inline">\(z = (z_1,z_2,..,z_N)\)</span> the total of the quantity of interest is <span class="math display">\[
Y(z) = \sum_{i=1}^N Y_i(z)
\]</span> where <span class="math inline">\(Y_i\)</span> is the quantity of interest for the <span class="math inline">\(i^{th}\)</span> individual. For our messaging example, <span class="math inline">\(Y_i\)</span> might be the total number of messages the user sent within a two week period. Notice at this point we are allowing that each individual’s behavior depends on the entire assignment vector!</p>
<p>The ulimate goal is to estimate <span id="eq-ate"><span class="math display">\[
\tau(\vec{1},\vec{0}) = \frac1N\sum_{i=1}^N \left(Y_i(\vec{1}) - Y_i(\vec{0}) \right)
\tag{2}\]</span></span> the Average Treatment Effect (ATE). Here <span class="math inline">\(\vec{1}\)</span> (<span class="math inline">\(\vec{0}\)</span>) is the assignment of <span class="math inline">\(1\)</span>s (<span class="math inline">\(0\)</span>s) to all individuals. Of course there is no world where we can simultaneously assign all units both 1 and 0, hence the goal of our study.</p>
<p>It would be hard to make it very far without making some kind of assumptions on the network effects. How can we make conclusions about <span class="math inline">\(\tau(\vec{1},\vec{0})\)</span> if we can’t isolate the assignment groups? The earliest paper I found in this direction is <span class="citation" data-cites="Ugander2013Graph">(<a href="#ref-Ugander2013Graph" role="doc-biblioref">Ugander et al. 2013</a>)</span>. The authors make the assumption of a <strong><em>net exposure condition</em></strong> which effectively assumes that if sufficiently many agents of an individuals neighborhood belong to a given assignment group, the individual will behave as if the entire network has that assignment. That is, for indivual <span class="math inline">\(v\in\mathcal{V}\)</span>, suppose there are <span class="math inline">\(k_i\)</span> individuals in <span class="math inline">\(A_{1,r}(v)\)</span> assigned <span class="math inline">\(z_j = 1 (0)\)</span>, then we can assume <span class="math inline">\(i\)</span> behaves as if <span class="math inline">\(z = \vec{1} (\vec{0})\)</span>. Explicit choices of <span class="math inline">\(k_i\)</span> can vary, but the authors consider <span class="math inline">\(k_i\)</span> the size of the neighborhood <span class="math inline">\(k_i = |A_{1,r}(v)|\)</span>, or a proportion of the neighborhood <span class="math inline">\(k_i = \kappa |A_{1,r}(v)|\)</span>, or simply a constant minimum over the network <span class="math inline">\(k_i = \kappa\)</span>.</p>
<p>The Ugander paper is notable because they tackle the problem of a globally connected network of individuals. Compare this to the more mature literature of estimating the ATE when there are groups of interacting agents <span class="citation" data-cites="Hudgens2008Causal">(<a href="#ref-Hudgens2008Causal" role="doc-biblioref">Hudgens and Halloran 2008</a>)</span>. In that paper, the population is stratified into groups, and interference is limited to individuals among the same group. For example, a group might be all students in a particular elementary school. The analogy of the net exposure condition, is the assumption that any two assignments of a fixed group are equivalent if they have the same number of individuals assigned to 1 and 0 respectively.</p>
<div class="callout callout-style-default callout-note callout-titled" title="Hudgens and Halloran, 2008">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-4-contents" aria-controls="callout-4" aria-expanded="true" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Hudgens and Halloran, 2008
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-4" class="callout-4-contents callout-collapse collapse show">
<div class="callout-body-container callout-body">
<p>The Hudgens and Halloran paper outlines detailed experiment designs. [Sampling proceedures] The goal is to measure quantities like (<a href="#eq-ate" class="quarto-xref">Equation&nbsp;2</a>) by group and by individual. They differentiate a number of different causal effects * Direct - The impact on <span class="math inline">\(Y_i\)</span> of altering a single individuals assignment <span class="math inline">\(z_i=0 \to z_i=1\)</span> while holding all other assigments fixed. * Indirect - The impact on <span class="math inline">\(Y_i\)</span> of altering the assignment of all other individuals <span class="math inline">\(\{z_j\}_{j\neq i}\)</span> of a group while holding <span class="math inline">\(z_i\)</span> fixed. * Total - A combination of direct and indirect effects.</p>
<p>With this variety of quatities the proceed to derive unbiased estimators for the ATEs. [State corollary of theorem 2]</p>
</div>
</div>
</div>
<p>papers <span class="citation" data-cites="Hudgens2008Causal">(<a href="#ref-Hudgens2008Causal" role="doc-biblioref">Hudgens and Halloran 2008</a>)</span>, <span class="citation" data-cites="Aronow2017Estimating">(<a href="#ref-Aronow2017Estimating" role="doc-biblioref">Aronow and Samii 2017</a>)</span>, <span class="citation" data-cites="Ugander2013Graph">(<a href="#ref-Ugander2013Graph" role="doc-biblioref">Ugander et al. 2013</a>)</span>, <span class="citation" data-cites="Eckles2017Design">(<a href="#ref-Eckles2017Design" role="doc-biblioref">Eckles, Karrer, and Ugander 2017</a>)</span></p>





<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-Aronow2017Estimating" class="csl-entry" role="listitem">
Aronow, Peter M., and Cyrus Samii. 2017. <span>“Estimating Average Causal Effects Under General Interference, with Application to a Social Network Experiment.”</span> <em>The Annals of Applied Statistics</em> 11 (4): 1912–47. <a href="http://www.jstor.org/stable/26362172">http://www.jstor.org/stable/26362172</a>.
</div>
<div id="ref-Eckles2017Design" class="csl-entry" role="listitem">
Eckles, Dean, Brian Karrer, and Johan Ugander. 2017. <span>“Design and Analysis of Experiments in Networks: Reducing Bias from Interference.”</span> <em>Journal of Causal Inference</em> 5 (1): 20150021.
</div>
<div id="ref-Hudgens2008Causal" class="csl-entry" role="listitem">
Hudgens, Michael G., and M. Elizabeth Halloran. 2008. <span>“Toward Causal Inference with Interference.”</span> <em>Journal of the American Statistical Association</em> 103 (482): 832–42. <a href="http://www.jstor.org/stable/27640105">http://www.jstor.org/stable/27640105</a>.
</div>
<div id="ref-Ugander2013Graph" class="csl-entry" role="listitem">
Ugander, Johan, Brian Karrer, Lars Backstrom, and Jon Kleinberg. 2013. <span>“Graph Cluster Randomization: Network Exposure to Multiple Universes.”</span> In <em>Proceedings of the 19th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining</em>, 329–37. KDD ’13. New York, NY, USA: Association for Computing Machinery. <a href="https://doi.org/10.1145/2487575.2487695">https://doi.org/10.1145/2487575.2487695</a>.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/www\.mavi\.phd");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>